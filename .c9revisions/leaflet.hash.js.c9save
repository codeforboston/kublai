{"ts":1376332237266,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"(function() {\r\n\r\n  L.Hash = L.Class.extend({\r\n    initialize: function(map, options) {\r\n      this.map = map;\r\n      this.options = options || {};\r\n      if (!this.options.path) {\r\n        if (this.options.lc) {\r\n          this.options.path = '{base}/{z}/{lat}/{lng}';\r\n        } else {\r\n          this.options.path = '{z}/{lat}/{lng}';\r\n        }\r\n      }\r\n      if (this.options.lc && !this.options.formatBase) {\r\n        this.options.formatBase = [\r\n          /[\\s\\:A-Z]/g, function(match) {\r\n            if (match.match(/\\s/)) {\r\n              return \"_\";\r\n            } else if (match.match(/\\:/)) {\r\n              return \"\";\r\n            }\r\n            if (match.match(/[A-Z]/)) {\r\n              return match.toLowerCase();\r\n            }\r\n          }\r\n        ];\r\n      }\r\n      if (this.map._loaded) {\r\n        return this.startListning();\r\n      } else {\r\n        return this.map.on(\"load\", this.startListning);\r\n      }\r\n    },\r\n    startListning: function() {\r\n      var onHashChange,\r\n        _this = this;\r\n      if (location.hash) {\r\n        this.updateFromState(this.parseHash(location.hash));\r\n      }\r\n      if (history.pushState) {\r\n        if (!location.hash) {\r\n          history.replaceState.apply(history, this.formatState());\r\n        }\r\n        window.onpopstate = function(event) {\r\n          if (event.state) {\r\n            return _this.updateFromState(event.state);\r\n          }\r\n        };\r\n        this.map.on(\"moveend\", function() {\r\n          var pstate;\r\n          pstate = _this.formatState();\r\n          if (location.hash !== pstate[2] && !_this.moving) {\r\n            return history.pushState.apply(history, pstate);\r\n          }\r\n        });\r\n      } else {\r\n        if (!location.hash) {\r\n          location.hash = this.formatState()[2];\r\n        }\r\n        onHashChange = function() {\r\n          var pstate;\r\n          pstate = _this.formatState();\r\n          if (location.hash !== pstate[2] && !_this.moving) {\r\n            return location.hash = pstate[2];\r\n          }\r\n        };\r\n        this.map.on(\"moveend\", onHashChange);\r\n        if (('onhashchange' in window) && (window.documentMode === void 0 || window.documentMode > 7)) {\r\n          window.onhashchange = function() {\r\n            if (location.hash) {\r\n              return _this.updateFromState(_this.parseHash(location.hash));\r\n            }\r\n          };\r\n        } else {\r\n          this.hashChangeInterval = setInterval(onHashChange, 50);\r\n        }\r\n      }\r\n      return this.map.on(\"baselayerchange\", function(e) {\r\n        var pstate, _ref;\r\n        _this.base = (_ref = _this.options.lc._layers[e.layer._leaflet_id].name).replace.apply(_ref, _this.options.formatBase);\r\n        pstate = _this.formatState();\r\n        if (history.pushState) {\r\n          if (location.hash !== pstate[2] && !_this.moving) {\r\n            return history.pushState.apply(history, pstate);\r\n          }\r\n        } else {\r\n          if (location.hash !== pstate[2] && !_this.moving) {\r\n            return location.hash = pstate[2];\r\n          }\r\n        }\r\n      });\r\n    },\r\n    parseHash: function(hash) {\r\n      var args, lat, latIndex, lngIndex, lon, out, path, zIndex, zoom;\r\n      path = this.options.path.split(\"/\");\r\n      zIndex = path.indexOf(\"{z}\");\r\n      latIndex = path.indexOf(\"{lat}\");\r\n      lngIndex = path.indexOf(\"{lng}\");\r\n      if (hash.indexOf(\"#\") === 0) {\r\n        hash = hash.substr(1);\r\n      }\r\n      args = hash.split(\"/\");\r\n      if (args.length > 2) {\r\n        zoom = parseInt(args[zIndex], 10);\r\n        lat = parseFloat(args[latIndex]);\r\n        lon = parseFloat(args[lngIndex]);\r\n        if (isNaN(zoom) || isNaN(lat) || isNaN(lon)) {\r\n          return false;\r\n        } else {\r\n          out = {\r\n            center: new L.LatLng(lat, lon),\r\n            zoom: zoom\r\n          };\r\n          if (args.length > 3) {\r\n            out.base = args[path.indexOf(\"{base}\")];\r\n            return out;\r\n          } else {\r\n            return out;\r\n          }\r\n        }\r\n      } else {\r\n        return false;\r\n      }\r\n    },\r\n    updateFromState: function(state) {\r\n      if (this.moving) {\r\n        return;\r\n      }\r\n      this.moving = true;\r\n      this.map.setView(state.center, state.zoom);\r\n      if (state.base) {\r\n        this.setBase(state.base);\r\n      }\r\n      this.moving = false;\r\n      return true;\r\n    },\r\n    formatState: function() {\r\n      var center, precision, state, template, zoom;\r\n      center = this.map.getCenter();\r\n      zoom = this.map.getZoom();\r\n      precision = Math.max(0, Math.ceil(Math.log(zoom) / Math.LN2));\r\n      state = {\r\n        center: center,\r\n        zoom: zoom\r\n      };\r\n      template = {\r\n        lat: center.lat.toFixed(precision),\r\n        lng: center.lng.toFixed(precision),\r\n        z: zoom\r\n      };\r\n      if (this.options.path.indexOf(\"{base}\") > -1) {\r\n        state.base = this.getBase();\r\n        template.base = state.base;\r\n      }\r\n      return [state, \"a\", '#' + L.Util.template(this.options.path, template)];\r\n    },\r\n    setBase: function(base) {\r\n      var i, inputs, len, _ref;\r\n      this.base = base;\r\n      inputs = this.options.lc._form.getElementsByTagName('input');\r\n      len = inputs.length;\r\n      i = 0;\r\n      while (i < len) {\r\n        if (inputs[i].name === 'leaflet-base-layers' && (_ref = this.options.lc._layers[inputs[i].layerId].name).replace.apply(_ref, this.options.formatBase) === base) {\r\n          inputs[i].checked = true;\r\n          this.options.lc._onInputClick();\r\n          return true;\r\n        }\r\n        i++;\r\n      }\r\n    },\r\n    getBase: function() {\r\n      var i, inputs, len, _ref;\r\n      if (this.base) {\r\n        return this.base;\r\n      }\r\n      inputs = this.options.lc._form.getElementsByTagName('input');\r\n      len = inputs.length;\r\n      i = 0;\r\n      while (i < len) {\r\n        if (inputs[i].name === 'leaflet-base-layers' && inputs[i].checked) {\r\n          this.base = (_ref = this.options.lc._layers[inputs[i].layerId].name).replace.apply(_ref, this.options.formatBase);\r\n          return this.base;\r\n        }\r\n      }\r\n      return false;\r\n    },\r\n    remove: function() {\r\n      this.map.off(\"moveend\");\r\n      if (window.onpopstate) {\r\n        window.onpopstate = null;\r\n      }\r\n      location.hash = \"\";\r\n      return clearInterval(this.hashChangeInterval);\r\n    }\r\n  });\r\n\r\n  L.hash = function(map, options) {\r\n    return new L.Hash(map, options);\r\n  };\r\n\r\n  L.Map.include({\r\n    addHash: function(options) {\r\n      if (this._loaded) {\r\n        this._hash = L.hash(this, options);\r\n      } else {\r\n        this.on(\"load\", function() {\r\n          return this._hash = L.hash(this, options);\r\n        });\r\n      }\r\n      return this;\r\n    },\r\n    removeHash: function() {\r\n      this._hash.remove();\r\n      return this;\r\n    }\r\n  });\r\n\r\n}).call(this);"]],"start1":0,"start2":0,"length1":0,"length2":6785}]],"length":6785}
{"contributors":[],"silentsave":false,"ts":1376332355490,"patch":[[{"diffs":[[0,"        ];\r\n"],[1,"      }if (location.hash) {\r\n        this.updateFromState(this.parseHash(location.hash));\r\n"],[0,"      }\r\n   "]],"start1":759,"start2":759,"length1":24,"length2":115},{"diffs":[[0,"sh));\r\n      }\r\n"],[-1,""],[0,"      if (this.m"]],"start1":855,"start2":855,"length1":32,"length2":32},{"diffs":[[0,"Listning"],[1,",this"],[0,");\r\n    "]],"start1":1001,"start2":1001,"length1":16,"length2":21},{"diffs":[[0,"n(event) {\r\n"],[1,"          \r\n"],[0,"          if"]],"start1":1392,"start2":1392,"length1":24,"length2":36},{"diffs":[[0,"= function() {\r\n"],[1,"          \r\n"],[0,"          var ps"]],"start1":1916,"start2":1916,"length1":32,"length2":44},{"diffs":[[0,"cation.hash) {\r\n"],[1,"              \r\n"],[0,"              re"]],"start1":2360,"start2":2360,"length1":32,"length2":48},{"diffs":[[0,"on(hash) {\r\n"],[1,"       \r\n"],[0,"      var ar"]],"start1":3222,"start2":3222,"length1":24,"length2":33},{"diffs":[[0,"plit(\"/\");\r\n"],[1," \r\n"],[0,"      if (ar"]],"start1":3576,"start2":3576,"length1":24,"length2":27},{"diffs":[[0,"      } else {\r\n"],[1,"         \r\n"],[0,"        return f"]],"start1":4134,"start2":4134,"length1":32,"length2":43},{"diffs":[[0," if (this.moving"],[1," || !state"],[0,") {\r\n        ret"]],"start1":4246,"start2":4246,"length1":32,"length2":42},{"diffs":[[0,"\r\n  "],[-1,"    if (this._loaded) {"],[0,"\r\n  "]],"start1":6614,"start2":6614,"length1":31,"length2":8},{"diffs":[[0,");\r\n"],[1,""],[0,"    "],[-1,"  } else {\r\n        this.on(\"load\", function() {\r\n          return this._hash = L.hash(this, options);\r\n        });\r\n      }"],[0,"\r\n  "]],"start1":6661,"start2":6661,"length1":136,"length2":12}]],"length":6807,"saved":false}
